#pragma config(Sensor, dgtl1,  solenoid1,      sensorDigitalOut)
#pragma config(Sensor, dgtl2,  solenoid2,      sensorDigitalOut)
#pragma config(Motor,  port2,           RwheelR,       tmotorVex393, openLoop)
#pragma config(Motor,  port3,           RwheelL,       tmotorVex393, openLoop)
#pragma config(Motor,  port4,           liftL,         tmotorVex393, openLoop)
#pragma config(Motor,  port5,           liftR,         tmotorVex393, openLoop)
#pragma config(Motor,  port6,           whiskL,        tmotorVex393, openLoop)
#pragma config(Motor,  port7,           whiskR,        tmotorVex393, openLoop)
#pragma config(Motor,  port8,           FwheelL,       tmotorVex393, openLoop)
#pragma config(Motor,  port9,           FwheelR,       tmotorVex393, openLoop)
#pragma config(UART_Usage, UART2, uartVEXLCD, baudRate19200, IOPins, None, None)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*
Project Title:
Team Members:                                                                                                                                                                                                                                                                                                                                         chris is the best
Date:b
Section:


Task Description:


Pseudocode: Is for Squares.

*/



//============================================| TASK DRIVE |============================================
task Drive()
{
	while(true)
	{
		motor[RwheelL]  = (vexRT[Ch2] + vexRT[Ch4])/2;  // (y + x)/2
		motor[FwheelL]  = (vexRT[Ch4] + vexRT[Ch2])/2;  // (y + x)/2
		motor[RwheelR] = (vexRT[Ch2] - vexRT[Ch4])/-2;  // (y - x)/2
		motor[FwheelR] = (vexRT[Ch4] - vexRT[Ch2])/2;   // (y - x)/2
	}
}
//====================================================================================================

//============================================| TASK LIFT |============================================
task Lift()
{
	while(true)
	{
		if(vexRT[Btn6UXmtr2] == 1)
		{
			motor[liftL] = 127;
			motor[liftR] = 127;
		}
		else
		{
			if(vexRT[Btn6DXmtr2] == 1)
			{
				motor[liftL] = -127;
				motor[liftR] = -127;
			}
			else
			{
				motor[liftL] = 0;
				motor[liftR] = 0;     }
		}
	}
}
//====================================================================================================

//==========================================|Task Throw|==============================================
task throw()
{
	while(true)
	{
		if(vexRT[Btn7R] == 1)
		{
			SensorValue[solenoid1] = 1;
		}
		else
		{
			SensorValue[solenoid1] = 0;
		}
	}
}
//====================================================================================================
//==========================================|Task Bar|==============================================
task bar()
{
	while(true)
	{
		if(vexRT[Btn7UXmtr2] == 1)
		{
			SensorValue[solenoid2] = 1;
		}
		else
		{
			SensorValue[solenoid2] = 0;
		}
	}
}
//==========================================|Task Spin|==============================================
task spin()
{
	while(true)
	{
		if(vexRT[Btn5UXmtr2] == 1)
		{
			motor(whiskL) = 127;
			motor(whiskR) = -127;
		}
		else
		{
			if(vexRT[Btn5DXmtr2] == 1)
			{
				motor(whiskL) = -127;
				motor(whiskR) = 127;
			}
			else if(vexRT[Btn8LXmtr2] == 1)
			{
				motor(whiskL) = 0;
				motor(whiskR) = 0;
			}
		}
	}
}
//+++++++++++++++++++++++++++++++++++++++++++++| MAIN |+++++++++++++++++++++++++++++++++++++++++++++++

//task main()
//{
//	while(1==1)
//	{
//		StartTask(Drive);   /*driver 1*/
//		StartTask(Lift);   /*driver 2*/
//		StartTask(throw);	/*driver 1*/
//		StartTask(bar);		/*driver 2*/
//		StartTask(spin);	/*driver 2*/
//	}
//}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

int lift_speed = 100;
int rightturn = 790; //millis to execute right turn
int leftturn = -800;
int turnaround = 1500;


void rotate(signed int check1){
	int wheel_speed = 100;
	if (check1 > 0){
		motor[RwheelL]= motor[FwheelL] = wheel_speed;
		motor[RwheelR] = motor[FwheelR] = wheel_speed;
	}
	else if(check1 < 0){
		motor[RwheelL]= motor[FwheelL] = -wheel_speed;
		motor[RwheelR] = motor[FwheelR] = -wheel_speed;
	}
}

void deckUp(void){
	motor[liftR] = motor[liftL] = lift_speed;
}

void moveForward(int direction){
	int left_speed = 80;
	int right_speed = -120;
	if (direction > 0){
		motor[RwheelR] = motor[FwheelR] = right_speed;
		motor[RwheelL] = motor[FwheelL] = left_speed;
	}
	else if (direction < 0){
		motor[RwheelR] = motor[FwheelR] = -right_speed;
		motor[RwheelL] = motor[FwheelL] = -left_speed;
	}
}

void deckDown(void){
	motor[liftL] = -127;
	motor[liftR] = -127;
}

void deckRemain(void){
	int keep_up = 50;
	motor[liftL] = motor[liftR] = keep_up;
}

void deckOff(void){
	motor[liftR] = motor[liftL] = 0;
}

void throwauto(void){
	SensorValue[solenoid1] = 1;
	wait10Msec(50);
	SensorValue[solenoid1] = 0;
}

void rotOut(){
	int rot_speed = 127;
	motor[whiskL] = -rot_speed;
	motor[whiskR] = rot_speed;
}

//rotates the whisks to bring balls in
void rotIn(void){
	int rot_speed = 127;
	motor[whiskL] = rot_speed;
	motor[whiskR] = -rot_speed;
}

void rotOff(void){
	motor[whiskL] = motor[whiskR] = 0;
}

void stopWheels(void){
	motor[FwheelL] = motor[FwheelR] = motor[RwheelL] = motor[RwheelR] = 0;
}


//all tasks are of form auto<autonomous-version><color><location>
//location is "A" for closest to bar, "B" for other position

void auto1blueA(void){
	//facing towards this colour's hanging pole, parallel to the side closest to it,
	//use the bumper behind it to line it up

	//moves forward and picks up buckyballs
	rotIn();
	wait1Msec(100);
	moveForward(1);
	wait1Msec(800);
	stopWheels();
	//turn around, continue rotating whisks inward to keep buckies on
	rotate(rightturn);
	wait1Msec(rightturn);
	stopWheels();
	moveForward(1);
	wait1Msec(500);
	stopWheels();
	rotate(rightturn);
	wait1Msec(rightturn);
	stopWheels();
	moveForward(1);
	deckUp();
	wait1Msec(500);
	//move forward over barricade
	moveForward(1);
	wait1Msec(4500);
	stopWheels();
	deckUp();
	wait1Msec(500);
	//whisk buckies outward
	rotOff();
	rotOut();
	wait1Msec(3000);
}

void auto1redA(void){
	//facing towards this colour's hanging pole, parallel to the side closest to it,
	//use the bumper behind it to line it up

	//moves forward and picks up buckyballs
	rotIn();
	wait1Msec(100);
	moveForward(1);
	wait1Msec(500);
	stopWheels();
	//turn around, continue rotating whisks inward to keep buckies on
	rotate(leftturn);
	wait1Msec(-leftturn);
	stopWheels();
	moveForward(1);
	wait1Msec(500);
	stopWheels();
	rotate(leftturn);
	wait1Msec(-leftturn);
	stopWheels();
	moveForward(1);
	deckUp();
	wait1Msec(500);
	//move forward over barricade
	moveForward(1);
	wait1Msec(4000);
	stopWheels();
	deckUp();
	wait1Msec(500);
	//whisk buckies outward
	rotOff();
	rotOut();
	wait1Msec(3000);
}
//face in sm. dir. as auto1blueA
void auto2blueA(void){
	rotIn();
	wait1Msec(100);
	moveForward(1);
	wait1Msec(1000);
	stopWheels();
	rotate(turnaround);
	wait1Msec(turnaround);
	stopWheels();
	//move forward over barricade
	moveForward(1);
	wait1Msec(1000);
	stopWheels();
	//whisk buckies outward into intermediate zone
	rotOff();
	rotOut();
	//backup, turn right
	moveForward(-1);
	wait1Msec(400);
	stopWheels();
	rotate(leftturn);
	wait1Msec(-leftturn);
	stopWheels();
	// move forward, then turn right to move large ball
	moveForward(1);
	wait1Msec(1000);
	stopWheels();
	rotate(rightturn);
	wait1Msec(rightturn);
	stopWheels();
	moveForward(1);
	rotOut();
	wait1Msec(400);
	stopWheels();
	rotOff();
	//complete later, see drawing in orange binder.
}

//start facing perpendicular to wall w./ goals
void auto3blueB(void){
	int Ti1 = 1000;	//time to get to rails
	int Ti2 = 1215; //time to get into position to knock balls over rail
	int Ti3 = 1300; //time to rotate and knock balls over rail
	int Ti4 = 3000; // time to get to goal post
	int Ti5 = 2000; // time to let bucky ball out
	//get whisks ready
	rotIn();
	wait10Msec(20);

	//elevate platform
	deckUp();
	wait1Msec(500);
	deckRemain();
	//go forward
	moveForward(1);
	wait1Msec(Ti1);
	stopWheels();
	//Turn left
	rotate(leftturn);
	wait1Msec(-leftturn);
	stopWheels();
	//move into position for goal and second large ball
	moveForward(1);
	wait1Msec(Ti2);
	stopWheels();
	//take right turn
	rotate(rightturn);
	wait1Msec(rightturn);
	stopWheels();
	//back up and shut off moving deck up
	//turn towards goal
	moveForward(-1);
	wait1Msec(600);
	stopWheels();
	//move deck all the way down
	deckDown();
	wait1Msec(Ti3);
	deckOff();
	//move up to the to the foot of the goal
	moveForward(1);
	wait1Msec(1700);
	stopWheels();
	//elevate deck and rotate whisks outward to score a "goal"
	deckUp();
	wait1Msec(1500);
	moveForward(1);
	wait1Msec(1000);
	stopWheels();
	rotOut();
	wait1Msec(2000);
	deckOff();
	rotOff();
}
void auto3redB(void){
	int Ti1 = 1000;	//time to get to rails
	int Ti2 = 1215; //time to get into position to knock balls over rail
	int Ti3 = 1300; //time to rotate and knock balls over rail
	int Ti4 = 3000; // time to get to goal post
	int Ti5 = 2000; // time to let bucky ball out
	//get whisks ready
	rotIn();
	wait10Msec(20);
	//elevate platform
	deckUp();
	wait1Msec(500);
	deckRemain();
	//go forward
	moveForward(1);
	wait1Msec(Ti1);
	stopWheels();
	//Turn left
	rotate(leftturn);
	wait1Msec(-leftturn);
	stopWheels();
	//move into position for goal and second large ball
	moveForward(1);
	wait1Msec(Ti2);
	stopWheels();
	//take right turn
	rotate(leftturn);
	wait1Msec(leftturn);
	stopWheels();
	//back up and shut off moving deck up
	//turn towards goal
	moveForward(-1);
	wait1Msec(600);
	stopWheels();
	//move deck all the way down
	deckDown();
	wait1Msec(Ti3);
	deckOff();
	//move up to the to the foot of the goal
	moveForward(1);
	wait1Msec(1700);
	stopWheels();
	//elevate deck and rotate whisks outward to score a "goal"
	deckUp();
	wait1Msec(1500);
	moveForward(1);
	wait1Msec(1000);
	stopWheels();
	rotOut();
	wait1Msec(2000);
	deckOff();
	rotOff();
}


const short leftButton = 1;
const short centerButton = 2;
const short rightButton = 4;

//Wait for Press--------------------------------------------------
void waitForPress()
{
	while(nLCDButtons == 0){}
	wait1Msec(5);
}
//----------------------------------------------------------------

//Wait for Release------------------------------------------------
void waitForRelease()
{
	while(nLCDButtons != 0){}
	wait1Msec(5);
}

void dispSideSelect(void){
	displayLCDCenteredString(0, "<< Red");
	displayLCDCenteredString(1, "Blue >>");
}

void chooseCode(int autoCode){
	clearLCDLine(0);
	clearLCDLine(1);
	switch(autoCode){
	case 0:
		displayLCDCenteredString(0,"auto1redA");
		displayLCDCenteredString(1,"Running");
		break;
	case 1:
		displayLCDCenteredString(0,"auto1blueA");
		displayLCDCenteredString(1,"Running");
		break;
	case 10:
		displayLCDCenteredString(0,"auto2redA");
		displayLCDCenteredString(1,"Running");
		break;
	case 11:
		displayLCDCenteredString(0,"auto2blueA");
		displayLCDCenteredString(1,"Running");
		break;
	case 20:
		displayLCDCenteredString(0,"auto2redB");
		displayLCDCenteredString(1,"Running");
		break;
	case 21:
		displayLCDCenteredString(0,"auto2blueB");
		displayLCDCenteredString(1,"Running");
		break;
	}
}
//----------------------------------------------------------------
void autonomousSide(int count){
	//------------- Beginning of Side Selection ---------------
	//Clear LCD
	int autoCode;
	clearLCDLine(0);
	clearLCDLine(1);
	displayLCDNumber(0, 0, count);
	//Switch Case that actually runs the user choice
	switch(count){
	case 0:
		//If count = 0, run the code correspoinding with choice 1
		dispSideSelect();
		waitForPress();
		if (nLCDButtons == leftButton){
			waitForRelease();
			autoCode = 0;
		}
		else if(nLCDButtons == rightButton){
			waitForRelease();
			autoCode = 1;
		}
		break;
	case 1:
		//If count = 1, run the code correspoinding with choice 2
		dispSideSelect();
		waitForPress();
		if (nLCDButtons == leftButton){
			waitForRelease();
			autoCode = 10;
		}
		else if(nLCDButtons == rightButton){
			waitForRelease();
			autoCode = 11;
		}
		break;
	case 2:
		//If count = 2, run the code correspoinding with choice 3
		dispSideSelect();
		waitForPress();
		if (nLCDButtons == leftButton){
			waitForRelease();
			autoCode = 20;
		}
		else if(nLCDButtons == rightButton){
			waitForRelease();
			autoCode = 21;
		}
		break;
	default:
		displayLCDCenteredString(0, "No valid choice");
		displayLCDCenteredString(1, "was made!");
		break;
	}
	chooseCode(autoCode);
	//------------- End of Robot Movement Code -----------------------
}


void autoCodeSelector(void)
{
	//Declare count variable to keep track of our choice
	int count = 0;

	//------------- Beginning of User Interface Code ---------------
	//Clear LCD
	clearLCDLine(0);
	clearLCDLine(1);
	//Loop while center button is not pressed
	while(nLCDButtons != centerButton)
	{
		//Switch case that allows the user to choose from 4 different options
		switch(count){
		case 0:
			//Display first choice
			displayLCDCenteredString(0, "Auto1-Hang");
			displayLCDCenteredString(1, "<		 Enter		>");
			waitForPress();
			//Increment or decrement "count" based on button press
			if(nLCDButtons == leftButton)
			{
				waitForRelease();
				count = 2;
			}
			else if(nLCDButtons == rightButton)
			{
				waitForRelease();
				count++;
			}
			break;
		case 1:
			//Display second choice
			displayLCDCenteredString(0, "Auto2-Hang");
			displayLCDCenteredString(1, "<		 Enter		>");
			waitForPress();
			//Increment or decrement "count" based on button press
			if(nLCDButtons == leftButton)
			{
				waitForRelease();
				count--;

			}
			else if(nLCDButtons == rightButton)
			{
				waitForRelease();
				count++;
			}
			break;
		case 2:
			//Display third choice
			displayLCDCenteredString(0, "Auto3-Mid");
			displayLCDCenteredString(1, "<		 Enter		>");
			waitForPress();
			//Increment or decrement "count" based on button press
			if(nLCDButtons == leftButton)
			{
				waitForRelease();
				count--;
			}
			else if(nLCDButtons == rightButton)
			{
				waitForRelease();
				count = 0;
			}
			break;
		default:
			count = 0;
			break;
		}
	}
	clearLCDLine(0);clearLCDLine(1);
	displayLCDNumber(0,0,count);
	autonomousSide(count);
}

task main(){
	auto1redA();
}

//------------- End of User Interface Code ---------------------
