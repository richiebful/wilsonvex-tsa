#pragma config(Sensor, dgtl1,  solenoid1,         sensorDigitalOut)
#pragma config(Sensor, dgtl2,  solenoid2,        sensorDigitalOut)
#pragma config(Motor,  port2,           RwheelR,   tmotorVex393, openLoop)
#pragma config(Motor,  port3,           RwheelL,    tmotorVex393, openLoop)
#pragma config(Motor,  port4,           liftL,         tmotorVex393, openLoop)
#pragma config(Motor,  port5,           liftR,         tmotorVex393, openLoop)
#pragma config(Motor,  port6,           whiskL,         tmotorVex393, openLoop)
#pragma config(Motor,  port7,           whiskR,         tmotorVex393, openLoop)
#pragma config(Motor,  port8,						FwheelL,				tmotorVex393, openLoop)
#pragma config(Motor,  port9,           FwheelR,            tmotorVex393, openLoop)

//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*
Project Title:
Team Members:                                                                                                                                                                                                                                                                                                                                         chris is the best
Date:b
Section:


Task Description:


Pseudocode: Is for Squares.

*/



//============================================| TASK DRIVE |============================================
task Drive()
{
	while(true)
  {
		motor[RwheelL]  = (vexRT[Ch2] + vexRT[Ch1])/2;  // (y + x)/2
		motor[FwheelL]  = (vexRT[Ch1] + vexRT[Ch2])/2;  // (y + x)/2
		motor[RwheelR] = (vexRT[Ch2] - vexRT[Ch1])/-2;  // (y - x)/2
		motor[FwheelR] = (vexRT[Ch1] - vexRT[Ch2])/2;   // (y - x)/2
	}
}
//====================================================================================================

//============================================| TASK LIFT |============================================
task Lift()
{
	while(true)
	{
    if(vexRT[Btn6UXmtr2] == 1)
    {
      motor[liftL] = 127;
      motor[liftR] = 127;
    }
    else
    {
      if(vexRT[Btn6DXmtr2] == 1)
     {
         motor[liftL] = -127;
         motor[liftR] = -127;
     }
    else
     {
      motor[liftL] = 0;
      motor[liftR] = 0;
     }
	 }
	}
}
//====================================================================================================

//==========================================|Task Throw|==============================================
task throw()
{
	while(true)
  {
		if(vexRT[Btn7R] == 1)
		{
			SensorValue[solenoid1] = 1;
	  }
	  else
	  {
	  	SensorValue[solenoid1] = 0;
	  }
	}
}
//====================================================================================================
//==========================================|Task Bar|==============================================
task bar()
{
	while(true)
	{
		if(vexRT[Btn7UXmtr2] == 1)
		{
			SensorValue[solenoid2] = 1;
	  }
	  else
	  {
	  	SensorValue[solenoid2] = 0;
	  }
  }
}
//==========================================|Task Spin|==============================================
task spin()
{
	while(true)
  {
	 if(vexRT[Btn5UXmtr2] == 1)
		{
		  motor(whiskL) = 127;
		  motor(whiskR) = -127;
	  }
	 else
    {
    if(vexRT[Btn5DXmtr2] == 1)
     {
	  	motor(whiskL) = -127;
	  	motor(whiskR) = 127;
	   }
	  else if(vexRT[Btn8LXmtr2] == 1)
	   {
		  motor(whiskL) = 0;
		  motor(whiskR) = 0;
	   }
    }
	 }
}
//+++++++++++++++++++++++++++++++++++++++++++++| MAIN |+++++++++++++++++++++++++++++++++++++++++++++++

task main()
{
while(1==1)
 {
  StartTask(Drive);   /*driver 1*/
	StartTask(Lift);   /*driver 2*/
  StartTask(throw);	/*driver 1*/
	StartTask(bar);		/*driver 2*/
	StartTask(spin);	/*driver 2*/
 }
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

int lift_speed = 50;
int lift_period = 2000;
int rightturn = 1000; //millis to execute right turn
int turnaround = -2000;
int leftturn = -1000;

void rotate(int check1){
	int wheel_setting = 20;
	if (check1 < 0){
		ClearTimer(T1);
		while (time1[T1] < check1){
			motor[RwheelL]= motor[FwheelL] = wheel_setting;
			motor[RwheelR] = motor[FwheelR] = -wheel_setting;
		}
		motor[RwheelR] = motor[FwheelR] = 0;
		motor[RwheelL] = motor[FwheelL] = 0;
  }
  else if(check1 > 0){
  	ClearTimer(T1);
  	while (time1[T1] < check1){
  		motor[RwheelL]= motor[FwheelL] = -wheel_setting;
  		motor[RwheelR] = motor[FwheelR] = wheel_setting;
  	}
  	motor[RwheelL] = motor[FwheelL] = 0;
  	motor[RwheelR] = motor[FwheelR] = 0;
	}
}

task deckUp(){
	motor[liftL] = lift_speed;
	motor[liftR] = -lift_speed;
	ClearTimer(T1);
	while(time1[T1] < lift_period){
		wait10Msec(10);
	}
	motor[liftL] = 0;
	motor[liftR] = 0;
}

void moveForward(int period){
	int wheel_setting = 50;
	motor[RwheelL] = motor[FwheelL] = -wheel_setting;
	motor[RwheelR] = motor[FwheelR] = wheel_setting;
	ClearTimer(T1);
	while(time1[T1] < period){
		wait10Msec(10);
	}
}

task deckDown(){
	motor[liftL] = -lift_speed;
	motor[liftR] = lift_speed;
	ClearTimer(T1);
	while(time1[T1] < lift_period){
		wait10Msec(10);
	}
	motor[liftL] = 0;
	motor[liftR] = 0;
}

void throwauto(void){
	SensorValue[solenoid2] = SensorValue[solenoid1] = 1;
	wait10Msec(50);
	SensorValue[solenoid2] = SensorValue[solenoid1] = 0;
}

void rotOut(int period){
	int rot_speed = 50;
	motor[whiskL] = -rot_speed;
	motor[whiskR] = rot_speed;
	ClearTimer(T1);
	while(time1[T1] < period){
		wait10Msec(10);
	}
	motor[whiskL] = motor[whiskR] = 0;
}

//rotates the whisks to bring balls in
void rotIn(int period){
	int rot_speed = 50;
	motor[whiskL] = rot_speed;
	motor[whiskR] = -rot_speed;
	ClearTimer(T1);
	while(time1[T1] < period){
		wait10Msec(10);
	}
	motor[whiskL] = motor[whiskR] = 0;
}


//all tasks are of form auto<autonomous-version><color><location>
//location is "A" for closest to bar, "B" for other position

task auto1blueA(){
	//setup: have it facing towards the blue hanging pole, parallel to the side
	//spin whisks inward left clockwise, right counter-c.
	int Ti1 = 2000;//time to get to gather bucky balls
	int Ti2 = 1000;//time tgt. alignment w/ back goal
	int Ti3 = 5000;//time tgt. back goals
	int Ti4 = 1000;//time to drop balls into goal
	rotIn(Ti1);
	moveForward(Ti1);
	rotate(rightturn);
	moveForward(Ti2);
	rotate(rightturn);
	moveForward(Ti3);
	StartTask(deckUp);
	rotOut(Ti4);
	rotate(turnaround);
	rotate(leftturn);
}

task auto1redA(){
	//setup: have it facing towards the blue hanging pole, parallel to the side
	//spin whisks inward left clockwise, right counter-c.
	int Ti1 = 2000;//time to get to gather bucky balls
	int Ti2 = 1000;//time tgt. alignment w/ back goal
	int Ti3 = 5000;//time tgt. back goals
	int Ti4 = 1000;//time to drop balls into goal
	rotIn(Ti1);
	moveForward(Ti1);
	rotate(rightturn);
	moveForward(Ti2);
	rotate(leftturn);
	moveForward(Ti3);
	StartTask(deckUp);
	rotOut(Ti4);
	rotate(turnaround);
	rotate(rightturn);
}

task auto2blueA(){
	int Ti1 = 1000;
	int Ti2 = 2000;//get Blue Ball
	int Ti3 = 3000;
	int Ti4 = 2400;
	int Ti5 = 2000;
	moveForward(Ti1);
	rotIn(Ti2);
	rotate(rightturn);
	moveForward(Ti3);
	StartTask(deckUp);
	throwauto();
	rotate(leftturn);
	moveForward(Ti4);
	rotate(turnaround);
	moveForward(Ti5);
}

task auto2redA(){
	int Ti1 = 1000;
	int Ti2 = 2000;//get Red Ball
	int Ti3 = 3000;
	int Ti4 = 2400;
	int Ti5 = 2000;
	moveForward(Ti1);
	rotIn(Ti2);
	rotate(leftturn);
	moveForward(Ti3);
	StartTask(deckUp);
	throwauto();
	rotate(rightturn);
	moveForward(Ti4);
	rotate(turnaround);
	moveForward(Ti5);
}

//task main(){
//	wait10Msec(100);
//	StartTask(auto1blueA);
//}
