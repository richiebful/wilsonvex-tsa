#pragma config(Sensor, dgtl1,  solenoid1,         sensorDigitalOut)
#pragma config(Sensor, dgtl2,  solenoid2,        sensorDigitalOut)
#pragma config(Motor,  port2,           RwheelR,   tmotorVex393, openLoop)
#pragma config(Motor,  port3,           RwheelL,    tmotorVex393, openLoop)
#pragma config(Motor,  port4,           liftL,         tmotorVex393, openLoop)
#pragma config(Motor,  port5,           liftR,         tmotorVex393, openLoop)
#pragma config(Motor,  port6,           whiskL,         tmotorVex393, openLoop)
#pragma config(Motor,  port7,           whiskR,         tmotorVex393, openLoop)
#pragma config(Motor,  port8,						FwheelL,				tmotorVex393, openLoop)
#pragma config(Motor,  port9,           FwheelR,            tmotorVex393, openLoop)

//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*
Project Title:
Team Members:                                                                                                                                                                                                                                                                                                                                         chris is the best
Date:b
Section:


Task Description:


Pseudocode: Is for Squares.

*/



//============================================| TASK DRIVE |============================================
task Drive()
{
	while(true)
  {
		motor[RwheelL]  = (vexRT[Ch2] + vexRT[Ch1])/2;  // (y + x)/2
		motor[FwheelL]  = (vexRT[Ch1] + vexRT[Ch2])/2;  // (y + x)/2
		motor[RwheelR] = (vexRT[Ch2] - vexRT[Ch1])/-2;  // (y - x)/2
		motor[FwheelR] = (vexRT[Ch1] - vexRT[Ch2])/2;   // (y - x)/2
	}
}
//====================================================================================================

//============================================| TASK LIFT |============================================
task Lift()
{
	while(true)
	{
    if(vexRT[Btn6UXmtr2] == 1)
    {
      motor[liftL] = 127;
      motor[liftR] = 127;
    }
    else
    {
      if(vexRT[Btn6DXmtr2] == 1)
     {
         motor[liftL] = -127;
         motor[liftR] = -127;
     }
    else
     {
      motor[liftL] = 0;
      motor[liftR] = 0;     }
	 }
	}
}
//====================================================================================================

//==========================================|Task Throw|==============================================
task throw()
{
	while(true)
  {
		if(vexRT[Btn7R] == 1)
		{
			SensorValue[solenoid1] = 1;
	  }
	  else
	  {
	  	SensorValue[solenoid1] = 0;
	  }
	}
}
//====================================================================================================
//==========================================|Task Bar|==============================================
task bar()
{
	while(true)
	{
		if(vexRT[Btn7UXmtr2] == 1)
		{
			SensorValue[solenoid2] = 1;
	  }
	  else
	  {
	  	SensorValue[solenoid2] = 0;
	  }
  }
}
//==========================================|Task Spin|==============================================
task spin()
{
	while(true)
  {
	 if(vexRT[Btn5UXmtr2] == 1)
		{
		  motor(whiskL) = 127;
		  motor(whiskR) = -127;
	  }
	 else
    {
    if(vexRT[Btn5DXmtr2] == 1)
     {
	  	motor(whiskL) = -127;
	  	motor(whiskR) = 127;
	   }
	  else if(vexRT[Btn8LXmtr2] == 1)
	   {
		  motor(whiskL) = 0;
		  motor(whiskR) = 0;
	   }
    }
	 }
}
//+++++++++++++++++++++++++++++++++++++++++++++| MAIN |+++++++++++++++++++++++++++++++++++++++++++++++

task main()
{
while(1==1)
 {
  StartTask(Drive);   /*driver 1*/
	StartTask(Lift);   /*driver 2*/
  StartTask(throw);	/*driver 1*/
	StartTask(bar);		/*driver 2*/
	StartTask(spin);	/*driver 2*/
 }
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

int lift_speed = 100;
int rightturn = 660; //millis to execute right turn
int leftturn = -560;
int turnaround = 1400;


void rotate(signed int check1){
	int wheel_speed = 100;
	if (check1 > 0){
		motor[RwheelL]= motor[FwheelL] = wheel_speed;
		motor[RwheelR] = motor[FwheelR] = wheel_speed;
  }
  else if(check1 < 0){
  	motor[RwheelL]= motor[FwheelL] = -wheel_speed;
  	motor[RwheelR] = motor[FwheelR] = -wheel_speed;
	}
}

void deckUp(void){
	motor[liftR] = motor[liftL] = lift_speed;
}

void moveForward(int direction){
	int left_speed = 80;
	int right_speed = -120;
	if (direction > 0){
		motor[RwheelR] = motor[FwheelR] = right_speed;
		motor[RwheelL] = motor[FwheelL] = left_speed;
	}
	else if (direction < 0){
		motor[RwheelR] = motor[FwheelR] = -right_speed;
		motor[RwheelL] = motor[FwheelL] = -left_speed;
}
}

void deckDown(void){
	motor[liftL] = -127;
	motor[liftR] = -127;
}

void deckRemain(void){
	int keep_up = 50;
	motor[liftL] = motor[liftR] = keep_up;
}

void deckOff(void){
 	motor[liftR] = motor[liftL] = 0;
}

void throwauto(void){
	SensorValue[solenoid1] = 1;
	wait10Msec(50);
	SensorValue[solenoid1] = 0;
}

void rotOut(){
	int rot_speed = 127;
	motor[whiskL] = -rot_speed;
	motor[whiskR] = rot_speed;
}

//rotates the whisks to bring balls in
void rotIn(void){
	int rot_speed = 127;
	motor[whiskL] = rot_speed;
	motor[whiskR] = -rot_speed;
}

void rotOff(void){
	motor[whiskL] = motor[whiskR] = 0;
}

void stopWheels(void){
	motor[FwheelL] = motor[FwheelR] = motor[RwheelL] = motor[RwheelR] = 0;
}


//all tasks are of form auto<autonomous-version><color><location>
//location is "A" for closest to bar, "B" for other position

void auto1blueA(void){
	//facing towards this colour's hanging pole, parallel to the side closest to it,
	//use the bumper behind it to line it up

	//moves forward and picks up buckyballs
	rotIn();
	wait1Msec(100);
	moveForward(1);
	wait1Msec(1000);
	stopWheels();
	//turn around, continue rotating whisks inward to keep buckies on
	rotate(turnaround);
	wait1Msec(turnaround);
	stopWheels();
	//move forward over barricade
	moveForward(1);
	wait1Msec(3500);
	stopWheels();
	//whisk buckies outward
	rotOff();
	rotOut();
	wait1Msec(3000);
}

void auto1redA(void){
	//facing towards this colour's hanging pole, parallel to the side closest to it,
	//use the bumper behind it to line it up

	//moves forward and picks up buckyballs
	rotIn();
	wait1Msec(100);
	moveForward(1);
	wait1Msec(1000);
	stopWheels();
	//turn around, continue rotating whisks inward to keep buckies on
	rotate(turnaround);
	wait1Msec(turnaround);
	stopWheels();
	//move forward over barricade
	moveForward(1);
	wait1Msec(3500);
	stopWheels();
	//whisk buckies outward
	rotOff();
	rotOut();
	wait1Msec(3000);
}

//task auto2blueA(){
//	int Ti1 = 1000;
//	int Ti2 = 2000;//get Blue Ball
//	int Ti3 = 3000;
//	int Ti4 = 2400;
//	int Ti5 = 2000;
//	moveForward(Ti1);
//	rotIn(Ti2);
//	rotate(rightturn);
//	moveForward(Ti3);
//	deckUp(3000);
//	throwauto();
//	rotate(leftturn);
//	moveForward(Ti4);
//	rotate(turnaround);
//	moveForward(Ti5);
//}

//task auto2redA(){
//	int Ti1 = 1000;
//	int Ti2 = 2000;//get Red Ball
//	int Ti3 = 3000;
//	int Ti4 = 2400;
//	int Ti5 = 2000;
//	moveForward(Ti1);
//	rotIn(Ti2);
//	rotate(leftturn);
//	moveForward(Ti3);
//	deckUp(3000);
//	throwauto();
//	rotate(rightturn);
//	moveForward(Ti4);
//	rotate(turnaround);
//	moveForward(Ti5);
//}

//start facing perpendicular to wall w./ goals
void auto3blueB(void){
	int Ti1 = 1000;	//time to get to rails
	int Ti2 = 1215; //time to get into position to knock balls over rail
	int Ti3 = 1300; //time to rotate and knock balls over rail
	int Ti4 = 3000; // time to get to goal post
	int Ti5 = 2000; // time to let bucky ball out
	//get whisks ready
	rotIn();
	wait10Msec(20);

	//elevate platform
	deckUp();
	wait1Msec(500);
	deckRemain();
	//go forward
	moveForward(1);
	wait1Msec(Ti1);
	stopWheels();
	//Turn left
	rotate(leftturn);
	wait1Msec(-leftturn);
	stopWheels();
	//move into position for goal and second large ball
	moveForward(1);
	wait1Msec(Ti2);
	stopWheels();
	//take right turn
	rotate(rightturn);
	wait1Msec(rightturn);
	stopWheels();
	//back up and shut off moving deck up
	//turn towards goal
	moveForward(-1);
	wait1Msec(600);
	stopWheels();
	//move deck all the way down
	deckDown();
	wait1Msec(Ti3);
	deckOff();
	//move up to the to the foot of the goal
	moveForward(1);
	wait1Msec(1700);
	stopWheels();
	//elevate deck and rotate whisks outward to score a "goal"
	deckUp();
	wait1Msec(1500);
	moveForward(1);
	wait1Msec(1000);
	stopWheels();
	rotOut();
	wait1Msec(2000);
	deckOff();
	rotOff();
}
void auto3redB(void){
	int Ti1 = 1000;	//time to get to rails
	int Ti2 = 1215; //time to get into position to knock balls over rail
	int Ti3 = 1300; //time to rotate and knock balls over rail
	int Ti4 = 3000; // time to get to goal post
	int Ti5 = 2000; // time to let bucky ball out
	//get whisks ready
	rotIn();
	wait10Msec(20);
	//elevate platform
	deckUp();
	wait1Msec(500);
	deckRemain();
	//go forward
	moveForward(1);
	wait1Msec(Ti1);
	stopWheels();
	//Turn left
	rotate(leftturn);
	wait1Msec(-leftturn);
	stopWheels();
	//move into position for goal and second large ball
	moveForward(1);
	wait1Msec(Ti2);
	stopWheels();
	//take right turn
	rotate(leftturn);
	wait1Msec(leftturn);
	stopWheels();
	//back up and shut off moving deck up
	//turn towards goal
	moveForward(-1);
	wait1Msec(600);
	stopWheels();
	//move deck all the way down
	deckDown();
	wait1Msec(Ti3);
	deckOff();
	//move up to the to the foot of the goal
	moveForward(1);
	wait1Msec(1700);
	stopWheels();
	//elevate deck and rotate whisks outward to score a "goal"
	deckUp();
	wait1Msec(1500);
	moveForward(1);
	wait1Msec(1000);
	stopWheels();
	rotOut();
	wait1Msec(2000);
	deckOff();
	rotOff();
}


//task main(){
//	auto3blueB();
//}
